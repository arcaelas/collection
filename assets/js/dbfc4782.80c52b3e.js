"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8749],{1895:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"caso-practico-analisis-datos","metadata":{"permalink":"/blog/caso-practico-analisis-datos","editUrl":"https://github.com/arcaelas/collection/blog/2024-06-27-caso-practico-analisis-datos.md","source":"@site/blog/2024-06-27-caso-practico-analisis-datos.md","title":"Caso pr\xe1ctico: An\xe1lisis de datos con Arcaelas Collection","description":"En este art\xedculo exploraremos un caso de uso real de Arcaelas Collection aplicado al an\xe1lisis de datos en una aplicaci\xf3n de comercio electr\xf3nico, mostrando c\xf3mo la API fluida y el tipado fuerte pueden transformar el c\xf3digo en soluciones m\xe1s elegantes y mantenibles.","date":"2024-06-27T00:00:00.000Z","tags":[{"inline":false,"label":"Colecci\xf3n","permalink":"/blog/tags/coleccion","description":"Funcionalidades del n\xfacleo de la librer\xeda Arcaelas Collection"},{"inline":false,"label":"Casos de Uso","permalink":"/blog/tags/casos-uso","description":"Ejemplos pr\xe1cticos de implementaci\xf3n de Arcaelas Collection"},{"inline":false,"label":"Rendimiento","permalink":"/blog/tags/rendimiento","description":"Optimizaci\xf3n y an\xe1lisis de rendimiento con Arcaelas Collection"},{"inline":false,"label":"TypeScript","permalink":"/blog/tags/typescript","description":"Art\xedculos sobre el uso de TypeScript con Arcaelas Collection"}],"readingTime":6.14,"hasTruncateMarker":true,"authors":[{"name":"Miguel Alejandro","title":"Desarrollador de Arcaelas Collection","url":"https://github.com/arcaelas","page":{"permalink":"/blog/authors/miguel"},"socials":{"github":"https://github.com/arcaelas"},"imageURL":"https://github.com/arcaelas.png","key":"miguel"}],"frontMatter":{"slug":"caso-practico-analisis-datos","title":"Caso pr\xe1ctico: An\xe1lisis de datos con Arcaelas Collection","authors":["miguel"],"tags":["colecci\xf3n","casos-uso","rendimiento","typescript"]},"unlisted":false,"nextItem":{"title":"Comparativa entre Arcaelas Collection y otras librer\xedas de manipulaci\xf3n de datos","permalink":"/blog/comparativa-collection-otras-librerias"}},"content":"En este art\xedculo exploraremos un caso de uso real de Arcaelas Collection aplicado al an\xe1lisis de datos en una aplicaci\xf3n de comercio electr\xf3nico, mostrando c\xf3mo la API fluida y el tipado fuerte pueden transformar el c\xf3digo en soluciones m\xe1s elegantes y mantenibles.\\n\\n\x3c!-- truncate --\x3e\\n\\n## El desaf\xedo: An\xe1lisis de ventas en un e-commerce\\n\\nImaginemos que estamos desarrollando el panel de an\xe1lisis para una plataforma de comercio electr\xf3nico y necesitamos implementar funcionalidades para:\\n\\n1. Analizar tendencias de ventas por per\xedodo y categor\xeda\\n2. Identificar productos m\xe1s vendidos y rentables\\n3. Segmentar clientes y analizar comportamientos de compra\\n4. Generar informes agregados con m\xe9tricas clave\\n\\nEstas operaciones implican manipular grandes vol\xfamenes de datos con estructuras complejas, filtrarlos, agruparlos y transformarlos.\\n\\n## Modelado de datos\\n\\nPrimero, definamos los tipos de datos con los que trabajaremos:\\n\\n```typescript\\n// Tipos para nuestro an\xe1lisis\\ninterface Producto {\\n  id: string;\\n  nombre: string;\\n  precio: number;\\n  categor\xeda: string;\\n  costo: number;\\n  stock: number;\\n  proveedor: string;\\n}\\n\\ninterface Cliente {\\n  id: string;\\n  nombre: string;\\n  email: string;\\n  fechaRegistro: Date;\\n  ubicaci\xf3n: string;\\n  segmento: \'nuevo\' | \'ocasional\' | \'frecuente\' | \'vip\';\\n}\\n\\ninterface Venta {\\n  id: string;\\n  fecha: Date;\\n  clienteId: string;\\n  productos: Array<{\\n    productoId: string;\\n    cantidad: number;\\n    precioUnitario: number;\\n    descuento: number;\\n  }>;\\n  total: number;\\n  m\xe9todo_pago: string;\\n  estado: \'completada\' | \'cancelada\' | \'reembolsada\';\\n}\\n```\\n\\n## Implementaci\xf3n tradicional vs. Collection\\n\\n### An\xe1lisis de ventas por per\xedodo y categor\xeda\\n\\n**Implementaci\xf3n tradicional:**\\n\\n```typescript\\nfunction analizarVentasPorPeriodo(\\n  ventas: Venta[], \\n  productos: Producto[],\\n  inicio: Date, \\n  fin: Date, \\n  categor\xeda?: string\\n) {\\n  // Filtrar ventas por per\xedodo\\n  const ventasFiltradas = ventas.filter(v => \\n    v.fecha >= inicio && \\n    v.fecha <= fin && \\n    v.estado === \'completada\'\\n  );\\n  \\n  // Preparar resultado\\n  const resultado: Record<string, number> = {};\\n  \\n  // Procesar cada venta\\n  ventasFiltradas.forEach(venta => {\\n    venta.productos.forEach(item => {\\n      const producto = productos.find(p => p.id === item.productoId);\\n      if (producto && (!categor\xeda || producto.categor\xeda === categor\xeda)) {\\n        const mes = `${venta.fecha.getMonth() + 1}-${venta.fecha.getFullYear()}`;\\n        if (!resultado[mes]) resultado[mes] = 0;\\n        resultado[mes] += item.cantidad * item.precioUnitario;\\n      }\\n    });\\n  });\\n  \\n  return Object.entries(resultado)\\n    .map(([periodo, total]) => ({ periodo, total }))\\n    .sort((a, b) => a.periodo.localeCompare(b.periodo));\\n}\\n```\\n\\n**Con Arcaelas Collection:**\\n\\n```typescript\\nimport { Collection } from \'@arcaelas/collection\';\\n\\nfunction analizarVentasPorPeriodo(\\n  ventas: Venta[], \\n  productos: Producto[],\\n  inicio: Date, \\n  fin: Date, \\n  categor\xeda?: string\\n) {\\n  const productosCollection = new Collection(productos);\\n  \\n  return new Collection(ventas)\\n    // Filtrar por per\xedodo y estado\\n    .where(v => v.fecha >= inicio && v.fecha <= fin && v.estado === \'completada\')\\n    // Expandir cada producto de cada venta\\n    .flatMap(venta => \\n      venta.productos.map(item => ({\\n        fecha: venta.fecha,\\n        productoId: item.productoId,\\n        importe: item.cantidad * item.precioUnitario\\n      }))\\n    )\\n    // Filtrar por categor\xeda si se especifica\\n    .filter(item => {\\n      if (!categor\xeda) return true;\\n      const producto = productosCollection.find(p => p.id === item.productoId);\\n      return producto?.categor\xeda === categor\xeda;\\n    })\\n    // Agregar per\xedodo (mes-a\xf1o)\\n    .map(item => ({\\n      ...item,\\n      periodo: `${item.fecha.getMonth() + 1}-${item.fecha.getFullYear()}`\\n    }))\\n    // Agrupar por per\xedodo y sumar importes\\n    .groupBy(\'periodo\')\\n    .map(grupo => ({\\n      periodo: grupo.key,\\n      total: grupo.items.sum(\'importe\')\\n    }))\\n    // Ordenar por per\xedodo\\n    .sortBy(\'periodo\');\\n}\\n```\\n\\n### Productos m\xe1s vendidos y rentables\\n\\n**Implementaci\xf3n tradicional:**\\n\\n```typescript\\nfunction obtenerProductosMasRentables(ventas: Venta[], productos: Producto[], l\xedmite = 10) {\\n  // Contabilizar ventas por producto\\n  const ventasPorProducto: Record<string, { unidades: number, ingresos: number }> = {};\\n  \\n  ventas.forEach(venta => {\\n    if (venta.estado !== \'completada\') return;\\n    \\n    venta.productos.forEach(item => {\\n      if (!ventasPorProducto[item.productoId]) {\\n        ventasPorProducto[item.productoId] = { unidades: 0, ingresos: 0 };\\n      }\\n      ventasPorProducto[item.productoId].unidades += item.cantidad;\\n      ventasPorProducto[item.productoId].ingresos += item.cantidad * item.precioUnitario;\\n    });\\n  });\\n  \\n  // Calcular rentabilidad\\n  const resultados = productos.map(producto => {\\n    const ventas = ventasPorProducto[producto.id] || { unidades: 0, ingresos: 0 };\\n    const costoTotal = ventas.unidades * producto.costo;\\n    const rentabilidad = ventas.ingresos - costoTotal;\\n    const margen = ventas.ingresos > 0 ? (rentabilidad / ventas.ingresos) * 100 : 0;\\n    \\n    return {\\n      id: producto.id,\\n      nombre: producto.nombre,\\n      categor\xeda: producto.categor\xeda,\\n      unidadesVendidas: ventas.unidades,\\n      ingresos: ventas.ingresos,\\n      rentabilidad,\\n      margen\\n    };\\n  });\\n  \\n  // Ordenar y limitar resultados\\n  return resultados\\n    .sort((a, b) => b.rentabilidad - a.rentabilidad)\\n    .slice(0, l\xedmite);\\n}\\n```\\n\\n**Con Arcaelas Collection:**\\n\\n```typescript\\nfunction obtenerProductosMasRentables(ventas: Venta[], productos: Producto[], l\xedmite = 10) {\\n  const ventasCollection = new Collection(ventas).where({ estado: \'completada\' });\\n  \\n  // Agregar ventas por producto\\n  const ventasPorProducto = ventasCollection\\n    .flatMap(v => v.productos)\\n    .groupBy(\'productoId\')\\n    .map(grupo => ({\\n      productoId: grupo.key,\\n      unidades: grupo.items.sum(\'cantidad\'),\\n      ingresos: grupo.items.sum(item => item.cantidad * item.precioUnitario)\\n    }))\\n    .keyBy(\'productoId\');\\n  \\n  // Calcular rentabilidad para cada producto\\n  return new Collection(productos)\\n    .map(producto => {\\n      const ventas = ventasPorProducto.get(producto.id) || { unidades: 0, ingresos: 0 };\\n      const costoTotal = ventas.unidades * producto.costo;\\n      const rentabilidad = ventas.ingresos - costoTotal;\\n      \\n      return {\\n        id: producto.id,\\n        nombre: producto.nombre,\\n        categor\xeda: producto.categor\xeda,\\n        unidadesVendidas: ventas.unidades,\\n        ingresos: ventas.ingresos,\\n        rentabilidad,\\n        margen: ventas.ingresos > 0 ? (rentabilidad / ventas.ingresos) * 100 : 0\\n      };\\n    })\\n    .sortByDesc(\'rentabilidad\')\\n    .take(l\xedmite);\\n}\\n```\\n\\n### Segmentaci\xf3n de clientes\\n\\n**Implementaci\xf3n tradicional:**\\n\\n```typescript\\nfunction segmentarClientes(clientes: Cliente[], ventas: Venta[]) {\\n  const resultados: Record<string, number> = {\\n    nuevo: 0,\\n    ocasional: 0,\\n    frecuente: 0,\\n    vip: 0\\n  };\\n  \\n  // Contar clientes por segmento\\n  clientes.forEach(cliente => {\\n    resultados[cliente.segmento]++;\\n  });\\n  \\n  // Calcular valor medio por segmento\\n  const ventasPorCliente: Record<string, number[]> = {\\n    nuevo: [],\\n    ocasional: [],\\n    frecuente: [],\\n    vip: []\\n  };\\n  \\n  // Agrupar ventas por cliente\\n  const ventasAgrupadas: Record<string, Venta[]> = {};\\n  ventas.forEach(venta => {\\n    if (venta.estado !== \'completada\') return;\\n    if (!ventasAgrupadas[venta.clienteId]) {\\n      ventasAgrupadas[venta.clienteId] = [];\\n    }\\n    ventasAgrupadas[venta.clienteId].push(venta);\\n  });\\n  \\n  // Calcular valor medio de compra por segmento\\n  clientes.forEach(cliente => {\\n    const clienteVentas = ventasAgrupadas[cliente.id] || [];\\n    const totalCompras = clienteVentas.reduce((suma, v) => suma + v.total, 0);\\n    if (clienteVentas.length > 0) {\\n      ventasPorCliente[cliente.segmento].push(totalCompras);\\n    }\\n  });\\n  \\n  // Calcular promedios\\n  const promedios: Record<string, number> = {};\\n  for (const segmento in ventasPorCliente) {\\n    const valores = ventasPorCliente[segmento];\\n    promedios[segmento] = valores.length > 0 \\n      ? valores.reduce((sum, val) => sum + val, 0) / valores.length \\n      : 0;\\n  }\\n  \\n  return {\\n    distribuci\xf3n: resultados,\\n    valorMedio: promedios\\n  };\\n}\\n```\\n\\n**Con Arcaelas Collection:**\\n\\n```typescript\\nfunction segmentarClientes(clientes: Cliente[], ventas: Venta[]) {\\n  const clientesCollection = new Collection(clientes);\\n  const ventasCollection = new Collection(ventas).where({ estado: \'completada\' });\\n  \\n  // Distribuci\xf3n por segmento\\n  const distribuci\xf3n = clientesCollection\\n    .countBy(\'segmento\');\\n  \\n  // Valor medio por segmento\\n  const valorMedio = clientesCollection\\n    .map(cliente => ({\\n      cliente,\\n      ventas: ventasCollection\\n        .where({ clienteId: cliente.id })\\n        .sum(\'total\')\\n    }))\\n    .where(item => item.ventas > 0)\\n    .groupBy(item => item.cliente.segmento)\\n    .map(grupo => ({\\n      segmento: grupo.key,\\n      valorMedio: grupo.items.average(\'ventas\')\\n    }))\\n    .keyBy(\'segmento\')\\n    .map(item => item.valorMedio)\\n    .toObject();\\n  \\n  return {\\n    distribuci\xf3n,\\n    valorMedio\\n  };\\n}\\n```\\n\\n## Generaci\xf3n de informes con datos agregados\\n\\nPara finalizar, veamos c\xf3mo crear un informe completo de rendimiento del negocio:\\n\\n```typescript\\nimport { Collection } from \'@arcaelas/collection\';\\n\\nfunction generarInformeRendimiento(ventas: Venta[], productos: Producto[], clientes: Cliente[], periodo: { inicio: Date, fin: Date }) {\\n  const ventasCollection = new Collection(ventas)\\n    .where(v => v.fecha >= periodo.inicio && v.fecha <= periodo.fin);\\n  \\n  const ventasCompletadas = ventasCollection.where({ estado: \'completada\' });\\n  const ventasCanceladas = ventasCollection.where({ estado: \'cancelada\' });\\n  \\n  // M\xe9tricas generales\\n  const ingresoTotal = ventasCompletadas.sum(\'total\');\\n  const numeroVentas = ventasCompletadas.length;\\n  const ticketMedio = numeroVentas > 0 ? ingresoTotal / numeroVentas : 0;\\n  const tasaCancelaci\xf3n = ventasCollection.length > 0 \\n    ? (ventasCanceladas.length / ventasCollection.length) * 100 \\n    : 0;\\n  \\n  // Ventas por d\xeda\\n  const ventasPorD\xeda = ventasCompletadas\\n    .groupBy(v => v.fecha.toISOString().substring(0, 10))\\n    .map(grupo => ({\\n      fecha: grupo.key,\\n      ventas: grupo.items.length,\\n      ingresos: grupo.items.sum(\'total\')\\n    }))\\n    .sortBy(\'fecha\');\\n  \\n  // Top categor\xedas\\n  const productosCollection = new Collection(productos);\\n  const topCategor\xedas = ventasCompletadas\\n    .flatMap(v => v.productos.map(p => ({\\n      productoId: p.productoId,\\n      importe: p.cantidad * p.precioUnitario\\n    })))\\n    .map(item => {\\n      const producto = productosCollection.find(p => p.id === item.productoId);\\n      return {\\n        categor\xeda: producto?.categor\xeda || \'Desconocida\',\\n        importe: item.importe\\n      };\\n    })\\n    .groupBy(\'categor\xeda\')\\n    .map(grupo => ({\\n      categor\xeda: grupo.key,\\n      importe: grupo.items.sum(\'importe\')\\n    }))\\n    .sortByDesc(\'importe\')\\n    .take(5);\\n  \\n  // Tasa de conversi\xf3n por segmento\\n  const clientesCollection = new Collection(clientes);\\n  const conversionPorSegmento = clientesCollection\\n    .groupBy(\'segmento\')\\n    .map(grupo => {\\n      const clientesIds = grupo.items.map(c => c.id);\\n      const compras = ventasCompletadas.where(v => clientesIds.includes(v.clienteId));\\n      const clientesCompraron = new Collection(compras.map(c => c.clienteId)).unique().length;\\n      \\n      return {\\n        segmento: grupo.key,\\n        total: grupo.items.length,\\n        compraron: clientesCompraron,\\n        tasa: (clientesCompraron / grupo.items.length) * 100\\n      };\\n    })\\n    .sortByDesc(\'tasa\');\\n  \\n  return {\\n    per\xedodo: {\\n      inicio: periodo.inicio,\\n      fin: periodo.fin\\n    },\\n    general: {\\n      ingresoTotal,\\n      numeroVentas,\\n      ticketMedio,\\n      tasaCancelaci\xf3n\\n    },\\n    tendencias: {\\n      ventasPorD\xeda,\\n      topCategor\xedas,\\n      conversionPorSegmento\\n    }\\n  };\\n}\\n```\\n\\n## Beneficios observados\\n\\nAl comparar ambos enfoques, podemos observar varias ventajas clave de utilizar Arcaelas Collection:\\n\\n1. **C\xf3digo m\xe1s expresivo**: Las operaciones encadenadas comunican claramente el flujo de transformaci\xf3n de datos.\\n\\n2. **Menos c\xf3digo boilerplate**: No hay necesidad de crear colecciones temporales ni gestionar manualmente estructuras intermedias.\\n\\n3. **Mejor mantenibilidad**: La estructura declarativa es m\xe1s f\xe1cil de comprender y modificar.\\n\\n4. **Tipado fuerte**: TypeScript proporciona autocompletado y detecci\xf3n temprana de errores en toda la cadena.\\n\\n5. **Rendimiento optimizado**: Las operaciones est\xe1n optimizadas para conjuntos de datos grandes.\\n\\n## Conclusi\xf3n\\n\\nEste caso pr\xe1ctico demuestra c\xf3mo Arcaelas Collection puede transformar c\xf3digo complejo de an\xe1lisis de datos en c\xf3digo m\xe1s limpio, expresivo y mantenible. Al utilizar la API fluida y las capacidades de agregaci\xf3n, podemos:\\n\\n- Reducir dr\xe1sticamente la cantidad de c\xf3digo necesario\\n- Mejorar la legibilidad y mantenibilidad\\n- Mantener el tipado fuerte en todas las operaciones\\n- Obtener mejor rendimiento en conjuntos grandes de datos\\n\\nPara equipos que trabajan con an\xe1lisis de datos en TypeScript, Arcaelas Collection ofrece una alternativa potente a los m\xe9todos tradicionales, reduciendo la complejidad y el riesgo de errores.\\n\\n\xbfHas implementado an\xe1lisis de datos con otras librer\xedas? \xbfC\xf3mo se compara tu experiencia con la API de Arcaelas Collection? \xa1Comparte tus pensamientos en los comentarios!"},{"id":"comparativa-collection-otras-librerias","metadata":{"permalink":"/blog/comparativa-collection-otras-librerias","editUrl":"https://github.com/arcaelas/collection/blog/2024-06-26-comparativa-collection.md","source":"@site/blog/2024-06-26-comparativa-collection.md","title":"Comparativa entre Arcaelas Collection y otras librer\xedas de manipulaci\xf3n de datos","description":"En el ecosistema JavaScript existen diversas herramientas para la manipulaci\xf3n de colecciones de datos. En este art\xedculo analizaremos las fortalezas y particularidades de Arcaelas Collection frente a otras alternativas populares.","date":"2024-06-26T00:00:00.000Z","tags":[{"inline":false,"label":"Colecci\xf3n","permalink":"/blog/tags/coleccion","description":"Funcionalidades del n\xfacleo de la librer\xeda Arcaelas Collection"},{"inline":false,"label":"Comparativa","permalink":"/blog/tags/comparativa","description":"An\xe1lisis comparativo entre Arcaelas Collection y otras librer\xedas"},{"inline":false,"label":"TypeScript","permalink":"/blog/tags/typescript","description":"Art\xedculos sobre el uso de TypeScript con Arcaelas Collection"},{"inline":false,"label":"Rendimiento","permalink":"/blog/tags/rendimiento","description":"Optimizaci\xf3n y an\xe1lisis de rendimiento con Arcaelas Collection"}],"readingTime":4.69,"hasTruncateMarker":true,"authors":[{"name":"Miguel Alejandro","title":"Desarrollador de Arcaelas Collection","url":"https://github.com/arcaelas","page":{"permalink":"/blog/authors/miguel"},"socials":{"github":"https://github.com/arcaelas"},"imageURL":"https://github.com/arcaelas.png","key":"miguel"}],"frontMatter":{"slug":"comparativa-collection-otras-librerias","title":"Comparativa entre Arcaelas Collection y otras librer\xedas de manipulaci\xf3n de datos","authors":["miguel"],"tags":["colecci\xf3n","comparativa","typescript","rendimiento"]},"unlisted":false,"prevItem":{"title":"Caso pr\xe1ctico: An\xe1lisis de datos con Arcaelas Collection","permalink":"/blog/caso-practico-analisis-datos"},"nextItem":{"title":"Patrones avanzados de uso en Arcaelas Collection","permalink":"/blog/patrones-avanzados-collection"}},"content":"En el ecosistema JavaScript existen diversas herramientas para la manipulaci\xf3n de colecciones de datos. En este art\xedculo analizaremos las fortalezas y particularidades de Arcaelas Collection frente a otras alternativas populares.\\n\\n\x3c!-- truncate --\x3e\\n\\n## El panorama actual de la manipulaci\xf3n de datos\\n\\nCuando se trata de trabajar con colecciones de datos en JavaScript, los desarrolladores tienen varias opciones:\\n\\n1. **Arrays nativos**: Los m\xe9todos integrados como `map`, `filter`, `reduce`.\\n2. **Lodash/Underscore**: Librer\xedas utilitarias con funciones para manipulaci\xf3n de datos.\\n3. **Immutable.js**: Estructura de datos inmutables con amplia API.\\n4. **Ramda**: Enfocada en programaci\xf3n funcional pura.\\n5. **Arcaelas Collection**: API fluida con fuerte tipado en TypeScript.\\n\\nVeamos c\xf3mo se comparan en diferentes aspectos.\\n\\n## Comparativa de sintaxis\\n\\n### Filtrado y ordenaci\xf3n\\n\\nComparemos c\xf3mo se realizan operaciones comunes de filtrado y ordenaci\xf3n:\\n\\n```typescript\\n// Datos de ejemplo\\nconst items = [\\n  { id: 1, nombre: \'Producto A\', precio: 150, categor\xeda: \'tecnolog\xeda\' },\\n  { id: 2, nombre: \'Producto B\', precio: 50, categor\xeda: \'hogar\' },\\n  { id: 3, nombre: \'Producto C\', precio: 250, categor\xeda: \'tecnolog\xeda\' },\\n  { id: 4, nombre: \'Producto D\', precio: 100, categor\xeda: \'hogar\' }\\n];\\n\\n// JavaScript nativo\\nconst resultado_js = items\\n  .filter(item => item.categor\xeda === \'tecnolog\xeda\')\\n  .sort((a, b) => a.precio - b.precio)\\n  .map(item => ({ id: item.id, nombre: item.nombre }));\\n\\n// Lodash\\nimport _ from \'lodash\';\\nconst resultado_lodash = _\\n  .chain(items)\\n  .filter({ categor\xeda: \'tecnolog\xeda\' })\\n  .sortBy(\'precio\')\\n  .map(item => _.pick(item, [\'id\', \'nombre\']))\\n  .value();\\n\\n// Arcaelas Collection\\nimport { Collection } from \'@arcaelas/collection\';\\nconst resultado_collection = new Collection(items)\\n  .where({ categor\xeda: \'tecnolog\xeda\' })\\n  .sortBy(\'precio\')\\n  .map(item => ({ id: item.id, nombre: item.nombre }));\\n```\\n\\n### Consultas complejas\\n\\nLas consultas m\xe1s complejas realmente destacan las diferencias:\\n\\n```typescript\\n// Filtrar productos de tecnolog\xeda con precio mayor a 100 y ordenar por precio\\n// JavaScript nativo\\nconst resultado_js = items\\n  .filter(item => item.categor\xeda === \'tecnolog\xeda\' && item.precio > 100)\\n  .sort((a, b) => a.precio - b.precio);\\n\\n// Lodash\\nconst resultado_lodash = _\\n  .chain(items)\\n  .filter(item => item.categor\xeda === \'tecnolog\xeda\' && item.precio > 100)\\n  .sortBy(\'precio\')\\n  .value();\\n\\n// Arcaelas Collection\\nconst resultado_collection = new Collection(items)\\n  .where(\'categor\xeda\', \'tecnolog\xeda\')\\n  .where(item => item.precio > 100)\\n  .sortBy(\'precio\');\\n\\n// Con operadores (exclusivo de Collection)\\nimport { Operator } from \'@arcaelas/collection\';\\nconst resultado_operators = new Collection(items)\\n  .where(\'categor\xeda\', \'tecnolog\xeda\')\\n  .where(\'precio\', Operator.gt(100))\\n  .sortBy(\'precio\');\\n```\\n\\n## Comparativa de rendimiento\\n\\nEl rendimiento puede variar seg\xfan el caso de uso, pero he aqu\xed algunas mediciones representativas:\\n\\n| Librer\xeda | Arrays peque\xf1os (100 elementos) | Arrays medianos (10,000 elementos) | Arrays grandes (100,000 elementos) |\\n|----------|--------------------------------|----------------------------------|-----------------------------------|\\n| Nativo   | \u2705 Muy r\xe1pido                  | \u2705 R\xe1pido                         | \u26a0\ufe0f Moderado                        |\\n| Lodash   | \u2705 R\xe1pido                      | \u2705 R\xe1pido                         | \u2705 R\xe1pido                          |\\n| Immutable.js | \u26a0\ufe0f Moderado (sobrecarga inicial) | \u2705 R\xe1pido | \u2705 Muy r\xe1pido para operaciones repetitivas |\\n| Ramda    | \u26a0\ufe0f Moderado                    | \u26a0\ufe0f Moderado                       | \u26a0\ufe0f Moderado                        |\\n| Collection | \u2705 R\xe1pido                    | \u2705 R\xe1pido                         | \u2705 R\xe1pido                          |\\n\\n### Benchmark para filtrado y mapeo\\n\\n```typescript\\n// Conjunto de datos grande (50,000 elementos)\\nconst datos = Array.from({ length: 50000 }, (_, i) => ({\\n  id: i,\\n  valor: Math.random() * 1000,\\n  tipo: i % 3 === 0 ? \'A\' : i % 3 === 1 ? \'B\' : \'C\'\\n}));\\n\\nconsole.time(\'Nativo\');\\nconst resultadoNativo = datos\\n  .filter(item => item.tipo === \'A\' && item.valor > 500)\\n  .map(item => ({ id: item.id, valorDoble: item.valor * 2 }));\\nconsole.timeEnd(\'Nativo\');\\n\\nconsole.time(\'Lodash\');\\nconst resultadoLodash = _\\n  .chain(datos)\\n  .filter(item => item.tipo === \'A\' && item.valor > 500)\\n  .map(item => ({ id: item.id, valorDoble: item.valor * 2 }))\\n  .value();\\nconsole.timeEnd(\'Lodash\');\\n\\nconsole.time(\'Collection\');\\nconst resultadoCollection = new Collection(datos)\\n  .where(item => item.tipo === \'A\' && item.valor > 500)\\n  .map(item => ({ id: item.id, valorDoble: item.valor * 2 }));\\nconsole.timeEnd(\'Collection\');\\n```\\n\\nLos resultados muestran que Collection tiene un rendimiento comparable a Lodash y superior al enfoque nativo en conjuntos de datos grandes, especialmente cuando se encadenan m\xfaltiples operaciones.\\n\\n## Comparativa de funcionalidades\\n\\n| Caracter\xedstica | Nativo | Lodash | Immutable.js | Ramda | Collection |\\n|---------------|--------|---------|------------|-------|-----------|\\n| Tipado fuerte (TypeScript) | \u26a0\ufe0f B\xe1sico | \u26a0\ufe0f V\xeda @types | \u2705 S\xed | \u26a0\ufe0f V\xeda @types | \u2705 Nativo |\\n| Encadenamiento fluido | \u26a0\ufe0f Limitado | \u2705 S\xed | \u2705 S\xed | \u2705 Parcial | \u2705 S\xed |\\n| Consultas avanzadas | \u274c No | \u26a0\ufe0f Parcial | \u26a0\ufe0f Parcial | \u26a0\ufe0f V\xeda composici\xf3n | \u2705 S\xed |\\n| Manejo de grupos (groupBy) | \u274c No (ES2023+) | \u2705 S\xed | \u2705 S\xed | \u2705 S\xed | \u2705 S\xed |\\n| Agregaciones | \u274c Limitado | \u2705 S\xed | \u2705 S\xed | \u2705 S\xed | \u2705 S\xed |\\n| Inmutabilidad | \u274c No | \u274c No | \u2705 S\xed | \u2705 S\xed | \u26a0\ufe0f Opcional |\\n| Operadores de consulta | \u274c No | \u274c No | \u26a0\ufe0f Limitado | \u274c No | \u2705 S\xed |\\n| Tama\xf1o de la biblioteca | \u2705 0 KB | \u26a0\ufe0f 24 KB min | \u26a0\ufe0f 16 KB min | \u26a0\ufe0f 10 KB min | \u2705 8 KB min |\\n\\n## Casos de uso ideales\\n\\n### JavaScript nativo\\n\\nIdeal para:\\n- Scripts simples y operaciones b\xe1sicas\\n- Proyectos donde el tama\xf1o del bundle es cr\xedtico\\n- Operaciones no encadenadas\\n\\n### Lodash\\n\\nIdeal para:\\n- Proyectos que ya lo utilizan para otras funcionalidades\\n- Desarrolladores familiarizados con su API\\n- Aplicaciones con manipulaciones de datos variadas pero no complejas\\n\\n### Immutable.js\\n\\nIdeal para:\\n- Aplicaciones grandes donde la inmutabilidad es crucial\\n- Integraci\xf3n con Redux u otros paradigmas de estado inmutable\\n- Operaciones repetitivas en las mismas estructuras\\n\\n### Ramda\\n\\nIdeal para:\\n- Programadores funcionales\\n- Composici\xf3n avanzada de funciones\\n- Proyectos que priorizan pureza y funciones de punto libre\\n\\n### Arcaelas Collection\\n\\nIdeal para:\\n- Proyectos TypeScript donde el tipado es primordial\\n- Consultas complejas y expresivas sobre colecciones\\n- Desarrolladores que valoran una API fluida e intuitiva\\n- Aplicaciones que requieren filtros complejos basados en operadores\\n\\n## Importancia del tipado en Collection\\n\\nUna de las principales ventajas de Collection frente a otras alternativas es su integraci\xf3n nativa con TypeScript:\\n\\n```typescript\\ninterface Usuario {\\n  id: number;\\n  nombre: string;\\n  edad: number;\\n  roles: string[];\\n}\\n\\n// Con Collection\\nconst usuarios = new Collection<Usuario>([\\n  { id: 1, nombre: \'Ana\', edad: 28, roles: [\'admin\', \'editor\'] },\\n  { id: 2, nombre: \'Carlos\', edad: 35, roles: [\'usuario\'] }\\n]);\\n\\n// TypeScript proporciona autocompletado y validaci\xf3n de tipos\\nconst admins = usuarios\\n  .where(u => u.roles.includes(\'admin\'))\\n  .sortBy(\'nombre\');\\n\\n// Los m\xe9todos preservan el tipo\\nconst nombreAdmins: string[] = admins.map(u => u.nombre).toArray();\\n\\n// Error detectado en tiempo de compilaci\xf3n\\nconst error = usuarios.map(u => u.rolles); // \u274c Property \'rolles\' does not exist\\n```\\n\\n## Conclusi\xf3n\\n\\nCada librer\xeda tiene su lugar en el ecosistema JavaScript:\\n\\n- **JavaScript nativo**: Simplicidad y disponibilidad universal\\n- **Lodash**: Utilidades variadas y batalla probada\\n- **Immutable.js**: Robustez en inmutabilidad y rendimiento\\n- **Ramda**: Elegancia funcional y composici\xf3n\\n- **Arcaelas Collection**: Expresividad, tipado fuerte y consultas avanzadas\\n\\nArcaelas Collection destaca por combinar lo mejor de estos mundos: la expresividad de Lodash, el tipado robusto de TypeScript, con operadores de consulta avanzados y un rendimiento optimizado.\\n\\nLa elecci\xf3n de la herramienta adecuada depender\xe1 de tus necesidades espec\xedficas, pero si est\xe1s desarrollando en TypeScript y necesitas manipular colecciones de datos con una API expresiva y bien tipada, Arcaelas Collection ofrece una experiencia superior.\\n\\n\xbfHas probado estas diferentes librer\xedas? \xbfCu\xe1l prefieres para tus proyectos y por qu\xe9? \xa1Comparte tu experiencia en los comentarios!"},{"id":"patrones-avanzados-collection","metadata":{"permalink":"/blog/patrones-avanzados-collection","editUrl":"https://github.com/arcaelas/collection/blog/2024-06-25-patrones-avanzados-collection.md","source":"@site/blog/2024-06-25-patrones-avanzados-collection.md","title":"Patrones avanzados de uso en Arcaelas Collection","description":"Arcaelas Collection no es solo una librer\xeda para manipular datos, sino una herramienta que permite implementar patrones de dise\xf1o avanzados con una sintaxis limpia y expresiva.","date":"2024-06-25T00:00:00.000Z","tags":[{"inline":false,"label":"Colecci\xf3n","permalink":"/blog/tags/coleccion","description":"Funcionalidades del n\xfacleo de la librer\xeda Arcaelas Collection"},{"inline":false,"label":"TypeScript","permalink":"/blog/tags/typescript","description":"Art\xedculos sobre el uso de TypeScript con Arcaelas Collection"},{"inline":false,"label":"Patrones","permalink":"/blog/tags/patrones","description":"Patrones de dise\xf1o y arquitectura con Arcaelas Collection"},{"inline":false,"label":"Rendimiento","permalink":"/blog/tags/rendimiento","description":"Optimizaci\xf3n y an\xe1lisis de rendimiento con Arcaelas Collection"}],"readingTime":4.79,"hasTruncateMarker":true,"authors":[{"name":"Miguel Alejandro","title":"Desarrollador de Arcaelas Collection","url":"https://github.com/arcaelas","page":{"permalink":"/blog/authors/miguel"},"socials":{"github":"https://github.com/arcaelas"},"imageURL":"https://github.com/arcaelas.png","key":"miguel"}],"frontMatter":{"slug":"patrones-avanzados-collection","title":"Patrones avanzados de uso en Arcaelas Collection","authors":["miguel"],"tags":["colecci\xf3n","typescript","patrones","rendimiento"]},"unlisted":false,"prevItem":{"title":"Comparativa entre Arcaelas Collection y otras librer\xedas de manipulaci\xf3n de datos","permalink":"/blog/comparativa-collection-otras-librerias"},"nextItem":{"title":"Novedades y hoja de ruta de Arcaelas Collection","permalink":"/blog/novedades-roadmap"}},"content":"Arcaelas Collection no es solo una librer\xeda para manipular datos, sino una herramienta que permite implementar patrones de dise\xf1o avanzados con una sintaxis limpia y expresiva.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Patr\xf3n Mediador con Collection\\n\\nEl patr\xf3n Mediador es ideal cuando necesitas centralizar la comunicaci\xf3n entre varios componentes. Utilizando Collection como mediador, puedes simplificar esta implementaci\xf3n:\\n\\n```typescript\\nimport { Collection } from \'@arcaelas/collection\';\\n\\n// Definici\xf3n de tipos para nuestro sistema de mensajer\xeda\\ntype Mensaje = {\\n  id: string;\\n  origen: string;\\n  destino: string;\\n  contenido: string;\\n  timestamp: number;\\n  le\xeddo: boolean;\\n};\\n\\n// Mediador basado en Collection\\nclass MediadorMensajes {\\n  private mensajes = new Collection<Mensaje>([]);\\n  \\n  enviarMensaje(origen: string, destino: string, contenido: string): Mensaje {\\n    const mensaje: Mensaje = {\\n      id: `msg_${Date.now()}`,\\n      origen,\\n      destino,\\n      contenido,\\n      timestamp: Date.now(),\\n      le\xeddo: false\\n    };\\n    \\n    this.mensajes.push(mensaje);\\n    return mensaje;\\n  }\\n  \\n  obtenerMensajesParaUsuario(usuario: string): Collection<Mensaje> {\\n    return this.mensajes.where(m => m.destino === usuario);\\n  }\\n  \\n  marcarComoLe\xeddo(id: string): boolean {\\n    const mensaje = this.mensajes.find(m => m.id === id);\\n    if (mensaje) {\\n      mensaje.le\xeddo = true;\\n      return true;\\n    }\\n    return false;\\n  }\\n  \\n  // M\xe9todo para an\xe1lisis de comunicaci\xf3n\\n  obtenerEstad\xedsticasConversaci\xf3n(usuario1: string, usuario2: string) {\\n    const conversacion = this.mensajes.where(m => \\n      (m.origen === usuario1 && m.destino === usuario2) || \\n      (m.origen === usuario2 && m.destino === usuario1)\\n    ).sortBy(\'timestamp\');\\n    \\n    return {\\n      totalMensajes: conversacion.length,\\n      mensajesNoLe\xeddos: conversacion.where({ le\xeddo: false }).length,\\n      primerMensaje: conversacion.first(),\\n      \xfaltimoMensaje: conversacion.last(),\\n      tiempoPromedioRespuesta: this.calcularTiempoPromedioRespuesta(conversacion)\\n    };\\n  }\\n  \\n  private calcularTiempoPromedioRespuesta(conversacion: Collection<Mensaje>): number {\\n    if (conversacion.length < 2) return 0;\\n    \\n    let tiempoTotal = 0;\\n    let contadorRespuestas = 0;\\n    \\n    conversacion.reduce((anterior, actual) => {\\n      if (anterior && anterior.origen !== actual.origen) {\\n        tiempoTotal += actual.timestamp - anterior.timestamp;\\n        contadorRespuestas++;\\n      }\\n      return actual;\\n    });\\n    \\n    return contadorRespuestas ? tiempoTotal / contadorRespuestas : 0;\\n  }\\n}\\n```\\n\\n## Patr\xf3n Observador con encadenamiento\\n\\nCollection permite implementar f\xe1cilmente un sistema de observadores con encadenamiento de m\xe9todos:\\n\\n```typescript\\nimport { Collection } from \'@arcaelas/collection\';\\n\\ntype Observer<T> = (data: T) => void;\\n\\nclass ObservableCollection<T> {\\n  private collection: Collection<T>;\\n  private observers = new Collection<Observer<Collection<T>>>([]);\\n  \\n  constructor(items: T[] = []) {\\n    this.collection = new Collection<T>(items);\\n  }\\n  \\n  // M\xe9todos para suscribir/desuscribir observadores\\n  subscribe(observer: Observer<Collection<T>>): ObservableCollection<T> {\\n    this.observers.push(observer);\\n    return this;\\n  }\\n  \\n  unsubscribe(observer: Observer<Collection<T>>): ObservableCollection<T> {\\n    this.observers = this.observers.filter(o => o !== observer);\\n    return this;\\n  }\\n  \\n  // Notificar cambios\\n  private notify(): ObservableCollection<T> {\\n    this.observers.forEach(observer => observer(this.collection));\\n    return this;\\n  }\\n  \\n  // Operaciones que modifican la colecci\xf3n\\n  add(item: T): ObservableCollection<T> {\\n    this.collection.push(item);\\n    return this.notify();\\n  }\\n  \\n  remove(predicate: (item: T) => boolean): ObservableCollection<T> {\\n    this.collection = this.collection.reject(predicate);\\n    return this.notify();\\n  }\\n  \\n  update(predicate: (item: T) => boolean, updater: (item: T) => T): ObservableCollection<T> {\\n    this.collection = this.collection.map(item => {\\n      if (predicate(item)) {\\n        return updater(item);\\n      }\\n      return item;\\n    });\\n    return this.notify();\\n  }\\n  \\n  // Acceso a la colecci\xf3n interna para operaciones de consulta\\n  get(): Collection<T> {\\n    return this.collection;\\n  }\\n}\\n\\n// Ejemplo de uso\\ntype Tarea = {\\n  id: string;\\n  t\xedtulo: string;\\n  completada: boolean;\\n};\\n\\nconst gestor = new ObservableCollection<Tarea>([\\n  { id: \'1\', t\xedtulo: \'Aprender Collection\', completada: false }\\n]);\\n\\n// Registrar observadores\\ngestor.subscribe(colecci\xf3n => {\\n  console.log(\'Tareas actualizadas:\', colecci\xf3n.toArray());\\n  console.log(\'Tareas pendientes:\', colecci\xf3n.where({ completada: false }).length);\\n});\\n\\n// Realizar operaciones\\ngestor\\n  .add({ id: \'2\', t\xedtulo: \'Implementar Observer\', completada: false })\\n  .update(t => t.id === \'1\', t => ({ ...t, completada: true }));\\n```\\n\\n## Patr\xf3n Estrategia para ordenaci\xf3n personalizada\\n\\nCollection permite implementar f\xe1cilmente el patr\xf3n Estrategia para ordenaciones complejas:\\n\\n```typescript\\nimport { Collection } from \'@arcaelas/collection\';\\n\\n// Definici\xf3n de tipos para productos\\ntype Producto = {\\n  id: string;\\n  nombre: string;\\n  precio: number;\\n  valoraci\xf3n: number;\\n  ventas: number;\\n  fecha: Date;\\n};\\n\\n// Interfaz para estrategias de ordenaci\xf3n\\ninterface EstrategiaOrdenaci\xf3n {\\n  ordenar(productos: Collection<Producto>): Collection<Producto>;\\n  nombre: string;\\n}\\n\\n// Implementaci\xf3n de diferentes estrategias\\nclass OrdenarPorPrecioAscendente implements EstrategiaOrdenaci\xf3n {\\n  nombre = \'Precio: menor a mayor\';\\n  ordenar(productos: Collection<Producto>): Collection<Producto> {\\n    return productos.sortBy(\'precio\');\\n  }\\n}\\n\\nclass OrdenarPorPrecioDescendente implements EstrategiaOrdenaci\xf3n {\\n  nombre = \'Precio: mayor a menor\';\\n  ordenar(productos: Collection<Producto>): Collection<Producto> {\\n    return productos.sortByDesc(\'precio\');\\n  }\\n}\\n\\nclass OrdenarPorRelevancia implements EstrategiaOrdenaci\xf3n {\\n  nombre = \'Relevancia\';\\n  ordenar(productos: Collection<Producto>): Collection<Producto> {\\n    // Algoritmo personalizado que combina valoraci\xf3n y ventas\\n    return productos.sort((a, b) => {\\n      const scoreA = a.valoraci\xf3n * 0.7 + (Math.log(a.ventas) * 0.3);\\n      const scoreB = b.valoraci\xf3n * 0.7 + (Math.log(b.ventas) * 0.3);\\n      return scoreB - scoreA; // Orden descendente\\n    });\\n  }\\n}\\n\\nclass OrdenarPorNovedad implements EstrategiaOrdenaci\xf3n {\\n  nombre = \'M\xe1s recientes primero\';\\n  ordenar(productos: Collection<Producto>): Collection<Producto> {\\n    return productos.sortByDesc(\'fecha\');\\n  }\\n}\\n\\n// Uso del contexto con estrategias intercambiables\\nclass Cat\xe1logoProductos {\\n  private productos: Collection<Producto>;\\n  private estrategiaActual: EstrategiaOrdenaci\xf3n;\\n  private estrategiasDisponibles: Collection<EstrategiaOrdenaci\xf3n>;\\n  \\n  constructor(productos: Producto[]) {\\n    this.productos = new Collection(productos);\\n    \\n    // Inicializar estrategias disponibles\\n    this.estrategiasDisponibles = new Collection([\\n      new OrdenarPorRelevancia(),\\n      new OrdenarPorPrecioAscendente(),\\n      new OrdenarPorPrecioDescendente(),\\n      new OrdenarPorNovedad()\\n    ]);\\n    \\n    // Estrategia por defecto\\n    this.estrategiaActual = this.estrategiasDisponibles.first();\\n  }\\n  \\n  cambiarEstrategia(nombreEstrategia: string): boolean {\\n    const estrategia = this.estrategiasDisponibles.find(e => e.nombre === nombreEstrategia);\\n    if (estrategia) {\\n      this.estrategiaActual = estrategia;\\n      return true;\\n    }\\n    return false;\\n  }\\n  \\n  obtenerEstrategiasDisponibles(): string[] {\\n    return this.estrategiasDisponibles.map(e => e.nombre).toArray();\\n  }\\n  \\n  obtenerProductosOrdenados(): Collection<Producto> {\\n    return this.estrategiaActual.ordenar(this.productos);\\n  }\\n  \\n  // M\xe9todo para filtrar y luego ordenar\\n  obtenerProductosFiltradosYOrdenados(filtro: (p: Producto) => boolean): Collection<Producto> {\\n    return this.estrategiaActual.ordenar(this.productos.where(filtro));\\n  }\\n}\\n```\\n\\n## Implementando un Repositorio con Collection\\n\\nCollection facilita la implementaci\xf3n del patr\xf3n Repositorio para acceso a datos:\\n\\n```typescript\\nimport { Collection } from \'@arcaelas/collection\';\\n\\n// Definir entidad\\ninterface Entidad {\\n  id: string;\\n}\\n\\n// Repositorio gen\xe9rico\\nabstract class Repositorio<T extends Entidad> {\\n  protected colecci\xf3n: Collection<T>;\\n  \\n  constructor(datos: T[] = []) {\\n    this.colecci\xf3n = new Collection<T>(datos);\\n  }\\n  \\n  // M\xe9todos CRUD b\xe1sicos\\n  obtenerTodos(): Collection<T> {\\n    return this.colecci\xf3n;\\n  }\\n  \\n  obtenerPorId(id: string): T | undefined {\\n    return this.colecci\xf3n.find(entidad => entidad.id === id);\\n  }\\n  \\n  crear(entidad: T): T {\\n    if (this.obtenerPorId(entidad.id)) {\\n      throw new Error(`Entidad con ID ${entidad.id} ya existe`);\\n    }\\n    this.colecci\xf3n.push(entidad);\\n    return entidad;\\n  }\\n  \\n  actualizar(entidad: T): boolean {\\n    const \xedndice = this.colecci\xf3n.findIndex(e => e.id === entidad.id);\\n    if (\xedndice === -1) return false;\\n    \\n    // Actualizar la entidad en la colecci\xf3n\\n    this.colecci\xf3n[\xedndice] = entidad;\\n    return true;\\n  }\\n  \\n  eliminar(id: string): boolean {\\n    const longitudAnterior = this.colecci\xf3n.length;\\n    this.colecci\xf3n = this.colecci\xf3n.reject(e => e.id === id);\\n    return longitudAnterior > this.colecci\xf3n.length;\\n  }\\n  \\n  // M\xe9todo para realizar consultas personalizadas\\n  consultar(predicado: (entidad: T) => boolean): Collection<T> {\\n    return this.colecci\xf3n.where(predicado);\\n  }\\n}\\n\\n// Ejemplo de implementaci\xf3n concreta\\ninterface Usuario extends Entidad {\\n  nombre: string;\\n  email: string;\\n  rol: string;\\n}\\n\\nclass RepositorioUsuarios extends Repositorio<Usuario> {\\n  // M\xe9todos espec\xedficos para usuarios\\n  obtenerPorEmail(email: string): Usuario | undefined {\\n    return this.colecci\xf3n.find(u => u.email === email);\\n  }\\n  \\n  obtenerPorRol(rol: string): Collection<Usuario> {\\n    return this.colecci\xf3n.where({ rol });\\n  }\\n  \\n  cambiarRol(id: string, nuevoRol: string): boolean {\\n    const usuario = this.obtenerPorId(id);\\n    if (!usuario) return false;\\n    \\n    usuario.rol = nuevoRol;\\n    return this.actualizar(usuario);\\n  }\\n}\\n```\\n\\n## Conclusi\xf3n\\n\\nArcaelas Collection facilita la implementaci\xf3n de patrones de dise\xf1o avanzados gracias a su API fluida y expresiva. Al combinar estos patrones con las capacidades de filtrado, mapeo y agregaci\xf3n de Collection, puedes desarrollar aplicaciones m\xe1s mantenibles y escalables.\\n\\nEstos patrones son especialmente \xfatiles cuando trabajas con aplicaciones de cierta complejidad, donde la manipulaci\xf3n de datos necesita ser organizada siguiendo principios de dise\xf1o s\xf3lidos.\\n\\n\xbfHas implementado otros patrones con Arcaelas Collection? \xa1Comparte tu experiencia en los comentarios!"},{"id":"novedades-roadmap","metadata":{"permalink":"/blog/novedades-roadmap","editUrl":"https://github.com/arcaelas/collection/blog/2024-05-15-novedades-roadmap.md","source":"@site/blog/2024-05-15-novedades-roadmap.md","title":"Novedades y hoja de ruta de Arcaelas Collection","description":"Con cada nueva versi\xf3n, Arcaelas Collection contin\xfaa evolucionando para ofrecer herramientas m\xe1s potentes y expresivas para la manipulaci\xf3n de datos. En este art\xedculo, exploramos las mejoras recientes y lo que nos depara el futuro.","date":"2024-05-15T00:00:00.000Z","tags":[{"inline":false,"label":"Colecci\xf3n","permalink":"/blog/tags/coleccion-alt","description":"Funcionalidades del n\xfacleo de la librer\xeda Arcaelas Collection"},{"inline":false,"label":"TypeScript","permalink":"/blog/tags/typescript","description":"Art\xedculos sobre el uso de TypeScript con Arcaelas Collection"},{"inline":false,"label":"Casos de Uso","permalink":"/blog/tags/casos-uso","description":"Ejemplos pr\xe1cticos de implementaci\xf3n de Arcaelas Collection"}],"readingTime":3.5,"hasTruncateMarker":true,"authors":[{"name":"Miguel Alejandro","title":"Desarrollador de Arcaelas Collection","url":"https://github.com/arcaelas","page":{"permalink":"/blog/authors/miguel"},"socials":{"github":"https://github.com/arcaelas"},"imageURL":"https://github.com/arcaelas.png","key":"miguel"}],"frontMatter":{"slug":"novedades-roadmap","title":"Novedades y hoja de ruta de Arcaelas Collection","authors":["miguel"],"tags":["coleccion","typescript","casos-uso"]},"unlisted":false,"prevItem":{"title":"Patrones avanzados de uso en Arcaelas Collection","permalink":"/blog/patrones-avanzados-collection"},"nextItem":{"title":"Casos de uso avanzados con Arcaelas Collection","permalink":"/blog/casos-uso-avanzados"}},"content":"Con cada nueva versi\xf3n, Arcaelas Collection contin\xfaa evolucionando para ofrecer herramientas m\xe1s potentes y expresivas para la manipulaci\xf3n de datos. En este art\xedculo, exploramos las mejoras recientes y lo que nos depara el futuro.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Novedades en la versi\xf3n actual\\n\\nLa \xfaltima versi\xf3n de Arcaelas Collection incluye varias mejoras significativas:\\n\\n### 1. Rendimiento optimizado\\n\\nHemos mejorado significativamente el rendimiento de las operaciones sobre grandes colecciones de datos:\\n\\n- **Algoritmos optimizados**: Implementaci\xf3n de algoritmos m\xe1s eficientes para operaciones como `where()`, `filter()` y `sortBy()`.\\n- **Evaluaci\xf3n perezosa**: Las operaciones se ejecutan solo cuando es necesario, reduciendo el uso de memoria y CPU.\\n- **Memorizaci\xf3n interna**: Cach\xe9 autom\xe1tico de resultados para consultas repetidas con los mismos par\xe1metros.\\n\\n```typescript\\n// Las operaciones encadenadas ahora son hasta 2x m\xe1s r\xe1pidas\\nconst resultado = usuarios\\n  .where({ activo: true })\\n  .sortBy(\'ultimoAcceso\', \'desc\')\\n  .take(100);\\n```\\n\\n### 2. Nuevos operadores de consulta\\n\\nSe han agregado nuevos operadores para consultas m\xe1s expresivas:\\n\\n```typescript\\nimport { Collection, Operator } from \'@arcaelas/collection\';\\n\\nconst usuarios = new Collection([/* ... */]);\\n\\n// Nuevo operador LIKE para b\xfasqueda con patrones\\nconst resultados = usuarios.where({\\n  email: { [Operator.LIKE]: \'%@gmail.com\' }\\n});\\n\\n// Nuevo operador DATE_BETWEEN para rangos de fechas\\nconst actividadReciente = registros.where({\\n  fecha: { [Operator.DATE_BETWEEN]: [\'2024-01-01\', \'2024-05-01\'] }\\n});\\n```\\n\\n### 3. Integraci\xf3n con TypeScript mejorada\\n\\nMejoramos significativamente el soporte para tipos gen\xe9ricos y la inferencia de tipos:\\n\\n```typescript\\n// Mejor inferencia de tipos en los resultados de las operaciones\\nconst usuarios: Collection<Usuario> = new Collection<Usuario>([/* ... */]);\\n\\n// TypeScript ahora infiere correctamente que esto es Collection<string>\\nconst correos = usuarios.pluck(\'email\');\\n\\n// Y esto es Collection<{nombre: string, email: string}>\\nconst datos = usuarios.pluck([\'nombre\', \'email\']);\\n```\\n\\n## Patrones avanzados de uso\\n\\n### Patr\xf3n observador con colecciones reactivas\\n\\n```typescript\\nimport { Collection } from \'@arcaelas/collection\';\\n\\nclass UsuariosStore {\\n  private usuarios = new Collection([/* datos iniciales */]);\\n  private observadores: Function[] = [];\\n  \\n  // Suscribirse a cambios\\n  subscribe(callback: Function) {\\n    this.observadores.push(callback);\\n    return () => {\\n      this.observadores = this.observadores.filter(cb => cb !== callback);\\n    };\\n  }\\n  \\n  // Notificar cambios\\n  private notificar() {\\n    this.observadores.forEach(callback => callback(this.usuarios));\\n  }\\n  \\n  // M\xe9todos para modificar datos\\n  agregarUsuario(usuario) {\\n    this.usuarios.push(usuario);\\n    this.notificar();\\n  }\\n  \\n  actualizarUsuario(id, datos) {\\n    this.usuarios = this.usuarios.map(u => \\n      u.id === id ? { ...u, ...datos } : u\\n    );\\n    this.notificar();\\n  }\\n  \\n  eliminarUsuario(id) {\\n    this.usuarios = this.usuarios.filter(u => u.id !== id);\\n    this.notificar();\\n  }\\n  \\n  // M\xe9todos para consultar datos\\n  getUsuarios(filtro = {}) {\\n    return this.usuarios.where(filtro);\\n  }\\n}\\n```\\n\\n### Composici\xf3n de consultas din\xe1micas\\n\\n```typescript\\nfunction construirConsulta(opciones) {\\n  // Comenzar con la colecci\xf3n completa\\n  let consulta = productos;\\n  \\n  // Aplicar filtros condicionales\\n  if (opciones.categoria) {\\n    consulta = consulta.where({ categoria: opciones.categoria });\\n  }\\n  \\n  if (opciones.precioMin || opciones.precioMax) {\\n    consulta = consulta.where(item => {\\n      const cumpleMin = opciones.precioMin ? item.precio >= opciones.precioMin : true;\\n      const cumpleMax = opciones.precioMax ? item.precio <= opciones.precioMax : true;\\n      return cumpleMin && cumpleMax;\\n    });\\n  }\\n  \\n  if (opciones.busqueda) {\\n    const termino = opciones.busqueda.toLowerCase();\\n    consulta = consulta.where(item => \\n      item.nombre.toLowerCase().includes(termino) || \\n      item.descripcion.toLowerCase().includes(termino)\\n    );\\n  }\\n  \\n  // Aplicar ordenamiento\\n  if (opciones.ordenarPor) {\\n    consulta = consulta.sortBy(opciones.ordenarPor, opciones.ordenDireccion || \'asc\');\\n  }\\n  \\n  // Aplicar paginaci\xf3n\\n  const pagina = opciones.pagina || 1;\\n  const porPagina = opciones.porPagina || 10;\\n  consulta = consulta.skip((pagina - 1) * porPagina).take(porPagina);\\n  \\n  return consulta;\\n}\\n```\\n\\n## Hoja de ruta: Lo que viene en futuras versiones\\n\\nEstamos trabajando en varias caracter\xedsticas emocionantes para futuras versiones:\\n\\n### 1. Soporte para operaciones as\xedncronas\\n\\nPr\xf3ximamente se incluir\xe1 soporte nativo para manejar promesas y operaciones as\xedncronas:\\n\\n```typescript\\n// Futuro API para operaciones as\xedncronas\\nconst resultados = await usuariosCollection\\n  .whereAsync(async usuario => {\\n    const permisos = await verificarPermisos(usuario.id);\\n    return permisos.includes(\'admin\');\\n  })\\n  .mapAsync(async usuario => {\\n    const estadisticas = await obtenerEstadisticas(usuario.id);\\n    return { ...usuario, estadisticas };\\n  });\\n```\\n\\n### 2. Integraci\xf3n con frameworks reactivos\\n\\nTrabajamos en adaptadores espec\xedficos para React, Vue y Angular:\\n\\n```typescript\\n// React Hook (pr\xf3ximamente)\\nfunction useCollection(initialData) {\\n  const [collection, setCollection] = useState(new Collection(initialData));\\n  \\n  // M\xe9todos que mantienen la reactividad\\n  const updateCollection = useCallback((updater) => {\\n    setCollection(prev => updater(prev));\\n  }, []);\\n  \\n  return [collection, updateCollection];\\n}\\n```\\n\\n### 3. Persistencia y sincronizaci\xf3n\\n\\nSe est\xe1 desarrollando un sistema para persistencia y sincronizaci\xf3n con almacenamiento local o remoto:\\n\\n```typescript\\n// Caracter\xedstica en desarrollo\\nconst usuariosPersistentes = new PersistentCollection(\'usuarios\', {\\n  storage: localStorage, // O IndexedDB, o una API remota\\n  syncInterval: 60000 // Sincronizar cada minuto\\n});\\n\\n// Los cambios se sincronizan autom\xe1ticamente\\nusuariosPersistentes.push(nuevoUsuario);\\n```\\n\\n## C\xf3mo contribuir\\n\\nArcaelas Collection es un proyecto de c\xf3digo abierto y damos la bienvenida a contribuciones. Si tienes ideas para mejorar la librer\xeda o has encontrado errores:\\n\\n1. Visita nuestro [repositorio en GitHub](https://github.com/arcaelas/collection)\\n2. Revisa los [issues abiertos](https://github.com/arcaelas/collection/issues)\\n3. Sigue nuestra gu\xeda de contribuci\xf3n para enviar pull requests\\n\\n## Conclusi\xf3n\\n\\nArcaelas Collection contin\xfaa evolucionando para ofrecer una experiencia m\xe1s potente, expresiva y eficiente para la manipulaci\xf3n de colecciones de datos. Con cada actualizaci\xf3n, nos acercamos m\xe1s a nuestra visi\xf3n de proporcionar la mejor librer\xeda de manipulaci\xf3n de colecciones para JavaScript y TypeScript.\\n\\n\xa1Mantente atento a nuestras pr\xf3ximas actualizaciones y no dudes en compartir tus casos de uso y sugerencias para mejorar la librer\xeda!"},{"id":"casos-uso-avanzados","metadata":{"permalink":"/blog/casos-uso-avanzados","editUrl":"https://github.com/arcaelas/collection/blog/2024-01-10-casos-uso-avanzados.md","source":"@site/blog/2024-01-10-casos-uso-avanzados.md","title":"Casos de uso avanzados con Arcaelas Collection","description":"Arcaelas Collection brilla especialmente cuando se enfrenta a escenarios complejos de manipulaci\xf3n de datos. En este art\xedculo, exploraremos algunos casos de uso avanzados que demuestran la potencia y flexibilidad de la librer\xeda.","date":"2024-01-10T00:00:00.000Z","tags":[{"inline":false,"label":"Colecci\xf3n","permalink":"/blog/tags/coleccion-alt","description":"Funcionalidades del n\xfacleo de la librer\xeda Arcaelas Collection"},{"inline":false,"label":"Casos de Uso","permalink":"/blog/tags/casos-uso","description":"Ejemplos pr\xe1cticos de implementaci\xf3n de Arcaelas Collection"},{"inline":false,"label":"TypeScript","permalink":"/blog/tags/typescript","description":"Art\xedculos sobre el uso de TypeScript con Arcaelas Collection"}],"readingTime":3.63,"hasTruncateMarker":true,"authors":[{"name":"Miguel Alejandro","title":"Desarrollador de Arcaelas Collection","url":"https://github.com/arcaelas","page":{"permalink":"/blog/authors/miguel"},"socials":{"github":"https://github.com/arcaelas"},"imageURL":"https://github.com/arcaelas.png","key":"miguel"}],"frontMatter":{"slug":"casos-uso-avanzados","title":"Casos de uso avanzados con Arcaelas Collection","authors":["miguel"],"tags":["coleccion","casos-uso","typescript"]},"unlisted":false,"prevItem":{"title":"Novedades y hoja de ruta de Arcaelas Collection","permalink":"/blog/novedades-roadmap"},"nextItem":{"title":"Transformaci\xf3n y mapeo de datos con Arcaelas Collection","permalink":"/blog/transformacion-mapeo-datos"}},"content":"Arcaelas Collection brilla especialmente cuando se enfrenta a escenarios complejos de manipulaci\xf3n de datos. En este art\xedculo, exploraremos algunos casos de uso avanzados que demuestran la potencia y flexibilidad de la librer\xeda.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Caso 1: An\xe1lisis de datos con operaciones encadenadas\\n\\nUn escenario com\xfan en aplicaciones modernas es el an\xe1lisis de datos con m\xfaltiples operaciones encadenadas:\\n\\n```typescript\\nimport { Collection } from \'@arcaelas/collection\';\\n\\n// Conjunto de datos de ventas mensuales\\nconst ventas = new Collection([\\n  { fecha: \'2023-01-15\', producto: \'Laptop\', cantidad: 5, precio_unitario: 1200, cliente_id: 101 },\\n  { fecha: \'2023-01-20\', producto: \'Monitor\', cantidad: 10, precio_unitario: 300, cliente_id: 102 },\\n  { fecha: \'2023-01-25\', producto: \'Teclado\', cantidad: 20, precio_unitario: 50, cliente_id: 103 },\\n  { fecha: \'2023-02-05\', producto: \'Laptop\', cantidad: 3, precio_unitario: 1200, cliente_id: 104 },\\n  { fecha: \'2023-02-15\', producto: \'Mouse\', cantidad: 30, precio_unitario: 25, cliente_id: 101 },\\n  { fecha: \'2023-02-28\', producto: \'Monitor\', cantidad: 8, precio_unitario: 300, cliente_id: 105 }\\n]);\\n\\n// An\xe1lisis: Total de ventas por producto, ordenado de mayor a menor\\nconst analisis_ventas = ventas\\n  .map(item => ({\\n    ...item, \\n    total: item.cantidad * item.precio_unitario\\n  }))\\n  .groupBy(\'producto\')\\n  .map((grupo, producto) => ({\\n    producto,\\n    unidades_vendidas: grupo.sum(\'cantidad\'),\\n    total_ventas: grupo.sum(\'total\'),\\n    ticket_promedio: grupo.average(\'total\')\\n  }))\\n  .sortBy(\'total_ventas\', \'desc\');\\n\\nconsole.log(analisis_ventas.toArray());\\n// [\\n//   { producto: \'Laptop\', unidades_vendidas: 8, total_ventas: 9600, ticket_promedio: 4800 },\\n//   { producto: \'Monitor\', unidades_vendidas: 18, total_ventas: 5400, ticket_promedio: 2700 },\\n//   ...\\n// ]\\n```\\n\\n## Caso 2: Gesti\xf3n de relaciones entre entidades\\n\\nArcaelas Collection facilita el trabajo con datos relacionados, simulando operaciones similares a las de bases de datos relacionales:\\n\\n```typescript\\n// Colecciones de datos relacionados\\nconst usuarios = new Collection([\\n  { id: 1, nombre: \'Ana Mart\xednez\', email: \'ana@ejemplo.com\' },\\n  { id: 2, nombre: \'Carlos Rodr\xedguez\', email: \'carlos@ejemplo.com\' },\\n  { id: 3, nombre: \'Elena L\xf3pez\', email: \'elena@ejemplo.com\' }\\n]);\\n\\nconst pedidos = new Collection([\\n  { id: 101, usuario_id: 1, fecha: \'2023-11-10\', total: 1250 },\\n  { id: 102, usuario_id: 2, fecha: \'2023-11-12\', total: 340 },\\n  { id: 103, usuario_id: 1, fecha: \'2023-11-15\', total: 890 },\\n  { id: 104, usuario_id: 3, fecha: \'2023-11-18\', total: 1600 }\\n]);\\n\\n// Unir datos (similar a JOIN en SQL)\\nconst pedidos_con_usuario = pedidos.map(pedido => {\\n  const usuario = usuarios.first(u => u.id === pedido.usuario_id);\\n  return {\\n    ...pedido,\\n    usuario: usuario ? { nombre: usuario.nombre, email: usuario.email } : null\\n  };\\n});\\n\\n// Estad\xedsticas por usuario\\nconst estadisticas_usuario = usuarios.map(usuario => {\\n  const pedidos_usuario = pedidos.where({ usuario_id: usuario.id });\\n  \\n  return {\\n    id: usuario.id,\\n    nombre: usuario.nombre,\\n    cantidad_pedidos: pedidos_usuario.length,\\n    total_gastado: pedidos_usuario.sum(\'total\'),\\n    pedido_promedio: pedidos_usuario.average(\'total\')\\n  };\\n});\\n```\\n\\n## Caso 3: Implementaci\xf3n de cach\xe9 y memoizaci\xf3n\\n\\nArcaelas Collection tambi\xe9n puede utilizarse para implementar estrategias de cach\xe9 eficientes:\\n\\n```typescript\\n// Cach\xe9 de resultados de consultas API\\nclass APICache {\\n  private cache = new Collection();\\n  \\n  async fetchWithCache(endpoint, params = {}) {\\n    const cacheKey = JSON.stringify({ endpoint, params });\\n    \\n    // Buscar en cach\xe9 primero\\n    const cached = this.cache.first(item => item.key === cacheKey);\\n    \\n    if (cached && Date.now() - cached.timestamp < 300000) { // Cach\xe9 v\xe1lida por 5 minutos\\n      console.log(\'Usando resultado en cach\xe9\');\\n      return cached.data;\\n    }\\n    \\n    // Si no est\xe1 en cach\xe9 o expir\xf3, hacer la petici\xf3n\\n    console.log(\'Obteniendo datos frescos\');\\n    try {\\n      const response = await fetch(`https://api.ejemplo.com/${endpoint}`, { \\n        method: \'POST\',\\n        body: JSON.stringify(params)\\n      });\\n      const data = await response.json();\\n      \\n      // Guardar en cach\xe9\\n      this.cache = this.cache\\n        .filter(item => item.key !== cacheKey) // Eliminar entrada anterior si existe\\n        .push({\\n          key: cacheKey,\\n          data,\\n          timestamp: Date.now()\\n        });\\n      \\n      // Limpiar cach\xe9 antiguo (mantener solo los \xfaltimos 50 items)\\n      if (this.cache.length > 50) {\\n        this.cache = this.cache\\n          .sortBy(\'timestamp\', \'desc\')\\n          .take(50);\\n      }\\n      \\n      return data;\\n    } catch (error) {\\n      console.error(\'Error al obtener datos:\', error);\\n      throw error;\\n    }\\n  }\\n}\\n```\\n\\n## Caso 4: Procesamiento de datos en tiempo real\\n\\nPara aplicaciones que manejan flujos de datos en tiempo real, Arcaelas Collection ofrece una forma elegante de procesar y analizar estos datos:\\n\\n```typescript\\n// Simulaci\xf3n de procesamiento de eventos en tiempo real\\nclass EventProcessor {\\n  private events = new Collection();\\n  private alertThreshold = 5;\\n  \\n  // M\xe9todo llamado cada vez que llega un nuevo evento\\n  processEvent(event) {\\n    // A\xf1adir timestamp al evento si no lo tiene\\n    const eventWithTimestamp = {\\n      ...event,\\n      processed_at: Date.now()\\n    };\\n    \\n    // A\xf1adir a la colecci\xf3n de eventos\\n    this.events.push(eventWithTimestamp);\\n    \\n    // Mantener solo los \xfaltimos 1000 eventos\\n    if (this.events.length > 1000) {\\n      this.events = this.events.sortBy(\'processed_at\', \'desc\').take(1000);\\n    }\\n    \\n    // Detectar patrones en los \xfaltimos 5 minutos\\n    const recientEvents = this.events.where(e => \\n      e.processed_at > Date.now() - 300000\\n    );\\n    \\n    // Analizar eventos por tipo\\n    const eventsByType = recientEvents.groupBy(\'type\');\\n    \\n    // Detectar anomal\xedas (muchos eventos de error en poco tiempo)\\n    if (eventsByType.error && eventsByType.error.length >= this.alertThreshold) {\\n      this.triggerAlert({\\n        type: \'error_spike\',\\n        count: eventsByType.error.length,\\n        message: `Se detectaron ${eventsByType.error.length} errores en los \xfaltimos 5 minutos`\\n      });\\n    }\\n    \\n    return eventWithTimestamp;\\n  }\\n  \\n  triggerAlert(alert) {\\n    console.log(\'\ud83d\udea8 ALERTA:\', alert.message);\\n    // Aqu\xed ir\xedan las acciones para notificar la alerta\\n  }\\n}\\n```\\n\\n## Conclusi\xf3n\\n\\nLos casos de uso presentados demuestran la versatilidad y potencia de Arcaelas Collection para escenarios complejos de manejo de datos. La combinaci\xf3n de operaciones encadenables, m\xe9todos expresivos y alto rendimiento hace que sea una herramienta valiosa para el desarrollo de aplicaciones modernas que requieren manipulaci\xf3n intensiva de datos.\\n\\nEn futuros art\xedculos exploraremos m\xe1s patrones avanzados y t\xe9cnicas de optimizaci\xf3n con Arcaelas Collection."},{"id":"transformacion-mapeo-datos","metadata":{"permalink":"/blog/transformacion-mapeo-datos","editUrl":"https://github.com/arcaelas/collection/blog/2023-10-20-transformacion-mapeo-datos.md","source":"@site/blog/2023-10-20-transformacion-mapeo-datos.md","title":"Transformaci\xf3n y mapeo de datos con Arcaelas Collection","description":"Despu\xe9s de filtrar y buscar elementos en una colecci\xf3n, el siguiente paso com\xfan es transformar o mapear esos datos para adaptarlos a las necesidades espec\xedficas de tu aplicaci\xf3n. Arcaelas Collection ofrece m\xe9todos potentes que simplifican estas operaciones.","date":"2023-10-20T00:00:00.000Z","tags":[{"inline":false,"label":"Colecci\xf3n","permalink":"/blog/tags/coleccion","description":"Funcionalidades del n\xfacleo de la librer\xeda Arcaelas Collection"},{"inline":false,"label":"Transformaci\xf3n","permalink":"/blog/tags/transformacion","description":"Manipulaci\xf3n y transformaci\xf3n de datos en colecciones"},{"inline":false,"label":"Mapeo","permalink":"/blog/tags/mapeo","description":"T\xe9cnicas para mapear y transformar datos"},{"inline":false,"label":"TypeScript","permalink":"/blog/tags/typescript","description":"Art\xedculos sobre el uso de TypeScript con Arcaelas Collection"}],"readingTime":2.21,"hasTruncateMarker":true,"authors":[{"name":"Miguel Alejandro","title":"Desarrollador de Arcaelas Collection","url":"https://github.com/arcaelas","page":{"permalink":"/blog/authors/miguel"},"socials":{"github":"https://github.com/arcaelas"},"imageURL":"https://github.com/arcaelas.png","key":"miguel"}],"frontMatter":{"slug":"transformacion-mapeo-datos","title":"Transformaci\xf3n y mapeo de datos con Arcaelas Collection","authors":["miguel"],"tags":["colecci\xf3n","transformaci\xf3n","mapeo","typescript"]},"unlisted":false,"prevItem":{"title":"Casos de uso avanzados con Arcaelas Collection","permalink":"/blog/casos-uso-avanzados"},"nextItem":{"title":"Filtrado y b\xfasqueda avanzada con Arcaelas Collection","permalink":"/blog/filtrado-busqueda-avanzada"}},"content":"Despu\xe9s de filtrar y buscar elementos en una colecci\xf3n, el siguiente paso com\xfan es transformar o mapear esos datos para adaptarlos a las necesidades espec\xedficas de tu aplicaci\xf3n. Arcaelas Collection ofrece m\xe9todos potentes que simplifican estas operaciones.\\n\\n\x3c!-- truncate --\x3e\\n\\n## M\xe9todos de transformaci\xf3n\\n\\nArcaelas Collection proporciona varios m\xe9todos para transformar datos de manera eficiente:\\n\\n### El m\xe9todo `map()`\\n\\nSimilar al m\xe9todo nativo de JavaScript pero con mejoras, permite transformar cada elemento de la colecci\xf3n:\\n\\n```typescript\\nimport { Collection } from \'@arcaelas/collection\';\\n\\nconst productos = new Collection([\\n  { id: 1, nombre: \'Laptop\', precio: 1200 },\\n  { id: 2, nombre: \'Tel\xe9fono\', precio: 800 },\\n  { id: 3, nombre: \'Mesa\', precio: 350 }\\n]);\\n\\n// Aplicar descuento del 10%\\nconst con_descuento = productos.map(item => ({\\n  ...item,\\n  precio_original: item.precio,\\n  precio: Math.round(item.precio * 0.9),\\n  descuento: \'10%\'\\n}));\\n\\nconsole.log(con_descuento[0]);\\n// { id: 1, nombre: \'Laptop\', precio_original: 1200, precio: 1080, descuento: \'10%\' }\\n```\\n\\n### El m\xe9todo `pluck()`\\n\\nExtrae valores espec\xedficos de cada elemento para crear un nuevo array:\\n\\n```typescript\\n// Obtener solo los nombres de los productos\\nconst nombres = productos.pluck(\'nombre\');\\n// [\'Laptop\', \'Tel\xe9fono\', \'Mesa\']\\n\\n// Obtener m\xfaltiples propiedades como objetos\\nconst resumidos = productos.pluck([\'id\', \'nombre\']);\\n// [{ id: 1, nombre: \'Laptop\' }, ...]\\n```\\n\\n### Agrupaci\xf3n con `groupBy()`\\n\\nOrganiza elementos en grupos basados en una propiedad o funci\xf3n:\\n\\n```typescript\\nconst usuarios = new Collection([\\n  { id: 1, nombre: \'Ana\', rol: \'admin\' },\\n  { id: 2, nombre: \'Carlos\', rol: \'usuario\' },\\n  { id: 3, nombre: \'Elena\', rol: \'admin\' },\\n  { id: 4, nombre: \'David\', rol: \'usuario\' }\\n]);\\n\\nconst por_rol = usuarios.groupBy(\'rol\');\\n// {\\n//   admin: [{ id: 1, ... }, { id: 3, ... }],\\n//   usuario: [{ id: 2, ... }, { id: 4, ... }]\\n// }\\n```\\n\\n## Transformaciones encadenadas\\n\\nUna de las ventajas m\xe1s importantes de Arcaelas Collection es la capacidad de encadenar transformaciones para crear flujos de procesamiento de datos complejos y expresivos:\\n\\n```typescript\\nconst resultado = productos\\n  .where(item => item.precio > 500) // Filtrar productos caros\\n  .map(item => ({                    // Aplicar descuento\\n    ...item,\\n    precio: Math.round(item.precio * 0.9),\\n  }))\\n  .sortBy(\'precio\')                  // Ordenar por precio\\n  .pluck([\'nombre\', \'precio\']);      // Extraer solo nombre y precio\\n```\\n\\n## Transformaciones avanzadas\\n\\n### Aplanar colecciones anidadas con `flatten()`\\n\\nSi tienes colecciones dentro de colecciones, puedes aplanarlas f\xe1cilmente:\\n\\n```typescript\\nconst departamentos = new Collection([\\n  { nombre: \'Ventas\', empleados: [{ id: 1, nombre: \'Ana\' }, { id: 2, nombre: \'Carlos\' }] },\\n  { nombre: \'IT\', empleados: [{ id: 3, nombre: \'Elena\' }, { id: 4, nombre: \'David\' }] }\\n]);\\n\\n// Extraer todos los empleados en una \xfanica colecci\xf3n plana\\nconst todos_empleados = departamentos\\n  .pluck(\'empleados\')\\n  .flatten();\\n```\\n\\n### Transformaci\xf3n condicional con `when()`\\n\\nAplica transformaciones solo si se cumple una condici\xf3n:\\n\\n```typescript\\nconst resultado = productos\\n  .when(\\n    condicion_externa, // Si esta condici\xf3n es true\\n    coleccion => coleccion.where({ disponible: true }), // Aplica este filtro\\n    coleccion => coleccion // Si no, devuelve la colecci\xf3n sin cambios\\n  );\\n```\\n\\n## Conclusi\xf3n\\n\\nLos m\xe9todos de transformaci\xf3n y mapeo de Arcaelas Collection permiten manipular datos de manera eficiente y expresiva, simplificando enormemente tareas comunes de procesamiento de datos. La capacidad de encadenar operaciones proporciona un flujo de trabajo fluido y mantenible.\\n\\nEn nuestro pr\xf3ximo art\xedculo, exploraremos t\xe9cnicas avanzadas para trabajar con relaciones y datos complejos usando Arcaelas Collection."},{"id":"filtrado-busqueda-avanzada","metadata":{"permalink":"/blog/filtrado-busqueda-avanzada","editUrl":"https://github.com/arcaelas/collection/blog/2023-08-15-filtrado-busqueda-avanzada.md","source":"@site/blog/2023-08-15-filtrado-busqueda-avanzada.md","title":"Filtrado y b\xfasqueda avanzada con Arcaelas Collection","description":"Una de las operaciones m\xe1s comunes al trabajar con colecciones de datos es filtrar y buscar elementos seg\xfan criterios espec\xedficos. Arcaelas Collection proporciona un potente sistema de filtrado que simplifica enormemente estas tareas.","date":"2023-08-15T00:00:00.000Z","tags":[{"inline":false,"label":"Colecci\xf3n","permalink":"/blog/tags/coleccion","description":"Funcionalidades del n\xfacleo de la librer\xeda Arcaelas Collection"},{"inline":false,"label":"Filtrado","permalink":"/blog/tags/filtrado","description":"M\xe9todos y t\xe9cnicas para filtrar datos con Arcaelas Collection"},{"inline":false,"label":"B\xfasqueda","permalink":"/blog/tags/busqueda","description":"T\xe9cnicas de b\xfasqueda en colecciones de datos"},{"inline":false,"label":"TypeScript","permalink":"/blog/tags/typescript","description":"Art\xedculos sobre el uso de TypeScript con Arcaelas Collection"}],"readingTime":1.92,"hasTruncateMarker":true,"authors":[{"name":"Miguel Alejandro","title":"Desarrollador de Arcaelas Collection","url":"https://github.com/arcaelas","page":{"permalink":"/blog/authors/miguel"},"socials":{"github":"https://github.com/arcaelas"},"imageURL":"https://github.com/arcaelas.png","key":"miguel"}],"frontMatter":{"slug":"filtrado-busqueda-avanzada","title":"Filtrado y b\xfasqueda avanzada con Arcaelas Collection","authors":["miguel"],"tags":["colecci\xf3n","filtrado","b\xfasqueda","typescript"]},"unlisted":false,"prevItem":{"title":"Transformaci\xf3n y mapeo de datos con Arcaelas Collection","permalink":"/blog/transformacion-mapeo-datos"},"nextItem":{"title":"Introducci\xf3n a Arcaelas Collection","permalink":"/blog/introduccion-arcaelas-collection"}},"content":"Una de las operaciones m\xe1s comunes al trabajar con colecciones de datos es filtrar y buscar elementos seg\xfan criterios espec\xedficos. Arcaelas Collection proporciona un potente sistema de filtrado que simplifica enormemente estas tareas.\\n\\n\x3c!-- truncate --\x3e\\n\\n## M\xe9todos de filtrado en Arcaelas Collection\\n\\nLa librer\xeda ofrece varios m\xe9todos para filtrar y buscar elementos, cada uno con diferentes capacidades y casos de uso:\\n\\n### El m\xe9todo `where()`\\n\\nEste m\xe9todo es la base del sistema de filtrado y permite realizar consultas complejas con una sintaxis clara y expresiva:\\n\\n```typescript\\nimport { Collection } from \'@arcaelas/collection\';\\n\\nconst productos = new Collection([\\n  { id: 1, nombre: \'Laptop\', precio: 1200, disponible: true, categor\xeda: \'Electr\xf3nica\' },\\n  { id: 2, nombre: \'Tel\xe9fono\', precio: 800, disponible: true, categor\xeda: \'Electr\xf3nica\' },\\n  { id: 3, nombre: \'Mesa\', precio: 350, disponible: false, categor\xeda: \'Muebles\' },\\n  { id: 4, nombre: \'Silla\', precio: 150, disponible: true, categor\xeda: \'Muebles\' }\\n]);\\n\\n// Filtrar productos disponibles\\nconst disponibles = productos.where({ disponible: true });\\n\\n// Filtrar por precio mayor a 500\\nconst premium = productos.where(item => item.precio > 500);\\n\\n// Combinaci\xf3n de filtros\\nconst electr\xf3nicos_disponibles = productos\\n  .where({ categor\xeda: \'Electr\xf3nica\' })\\n  .where({ disponible: true });\\n```\\n\\n### Operadores de comparaci\xf3n\\n\\nArcaelas Collection soporta operadores avanzados para consultas m\xe1s expresivas:\\n\\n```typescript\\nimport { Collection, Operator } from \'@arcaelas/collection\';\\n\\n// Productos con precio entre 300 y 1000\\nconst rango_medio = productos.where({\\n  precio: { [Operator.BETWEEN]: [300, 1000] }\\n});\\n\\n// Productos que contienen \'o\' en el nombre\\nconst con_o = productos.where({\\n  nombre: { [Operator.CONTAINS]: \'o\' }\\n});\\n\\n// Productos con id en una lista espec\xedfica\\nconst lista_ids = productos.where({\\n  id: { [Operator.IN]: [1, 3] }\\n});\\n```\\n\\n### M\xe9todos de b\xfasqueda\\n\\nPara encontrar elementos espec\xedficos, Arcaelas Collection ofrece varios m\xe9todos \xfatiles:\\n\\n```typescript\\n// Encontrar el primer producto disponible\\nconst primer_disponible = productos.first(item => item.disponible);\\n\\n// Encontrar por ID\\nconst producto_id_2 = productos.find(item => item.id === 2);\\n\\n// Comprobar si existe alg\xfan producto de muebles\\nconst hay_muebles = productos.some(item => item.categor\xeda === \'Muebles\');\\n\\n// Comprobar si todos los productos cuestan m\xe1s de 100\\nconst todos_caros = productos.every(item => item.precio > 100);\\n```\\n\\n## Encadenamiento de operaciones\\n\\nUna de las grandes ventajas de Arcaelas Collection es la capacidad de encadenar operaciones para crear flujos de procesamiento de datos complejos:\\n\\n```typescript\\n// Filtrar, ordenar y limitar\\nconst top_electronica = productos\\n  .where({ categor\xeda: \'Electr\xf3nica\' })\\n  .where({ disponible: true })\\n  .sortBy(\'precio\', \'desc\')\\n  .take(2);\\n```\\n\\n## Rendimiento optimizado\\n\\nEl sistema de filtrado de Arcaelas Collection est\xe1 optimizado para manejar grandes colecciones de datos, implementando estrategias internas para minimizar el recorrido de elementos y maximizar la eficiencia de las consultas.\\n\\nEn nuestro pr\xf3ximo art\xedculo, exploraremos las capacidades de transformaci\xf3n y mapeo de datos que ofrece Arcaelas Collection para procesar y modificar colecciones."},{"id":"introduccion-arcaelas-collection","metadata":{"permalink":"/blog/introduccion-arcaelas-collection","editUrl":"https://github.com/arcaelas/collection/blog/2023-06-25-introduccion-arcaelas-collection.md","source":"@site/blog/2023-06-25-introduccion-arcaelas-collection.md","title":"Introducci\xf3n a Arcaelas Collection","description":"Arcaelas Collection es una librer\xeda TypeScript moderna para manipulaci\xf3n de colecciones de datos con una API fluida y expresiva, dise\xf1ada para ofrecer un manejo eficiente de datos en aplicaciones JavaScript/TypeScript.","date":"2023-06-25T00:00:00.000Z","tags":[{"inline":false,"label":"Colecci\xf3n","permalink":"/blog/tags/coleccion","description":"Funcionalidades del n\xfacleo de la librer\xeda Arcaelas Collection"},{"inline":false,"label":"Introducci\xf3n","permalink":"/blog/tags/introduccion","description":"Art\xedculos introductorios sobre Arcaelas Collection"},{"inline":false,"label":"TypeScript","permalink":"/blog/tags/typescript","description":"Art\xedculos sobre el uso de TypeScript con Arcaelas Collection"}],"readingTime":1.4,"hasTruncateMarker":true,"authors":[{"name":"Miguel Alejandro","title":"Desarrollador de Arcaelas Collection","url":"https://github.com/arcaelas","page":{"permalink":"/blog/authors/miguel"},"socials":{"github":"https://github.com/arcaelas"},"imageURL":"https://github.com/arcaelas.png","key":"miguel"}],"frontMatter":{"slug":"introduccion-arcaelas-collection","title":"Introducci\xf3n a Arcaelas Collection","authors":["miguel"],"tags":["colecci\xf3n","introducci\xf3n","typescript"]},"unlisted":false,"prevItem":{"title":"Filtrado y b\xfasqueda avanzada con Arcaelas Collection","permalink":"/blog/filtrado-busqueda-avanzada"}},"content":"Arcaelas Collection es una librer\xeda TypeScript moderna para manipulaci\xf3n de colecciones de datos con una API fluida y expresiva, dise\xf1ada para ofrecer un manejo eficiente de datos en aplicaciones JavaScript/TypeScript.\\n\\n\x3c!-- truncate --\x3e\\n\\n## \xbfPor qu\xe9 Arcaelas Collection?\\n\\nTrabajar con colecciones de datos es una tarea com\xfan en el desarrollo de aplicaciones. Ya sea que est\xe9s filtrando registros de usuarios, transformando resultados de una API o manipulando estructuras de datos complejas, necesitas herramientas que simplifiquen estas operaciones.\\n\\nAunque JavaScript ofrece m\xe9todos nativos como `map`, `filter` y `reduce`, Arcaelas Collection proporciona una experiencia m\xe1s rica y fluida con operaciones encadenables, consultas avanzadas y tipado fuerte.\\n\\n## Caracter\xedsticas principales\\n\\n1. **API fluida y expresiva**: Encadena m\xfaltiples operaciones para transformaciones complejas.\\n2. **Tipado fuerte**: Desarrollada completamente en TypeScript para ofrecer autocompletado y detecci\xf3n temprana de errores.\\n3. **Rendimiento optimizado**: Dise\xf1ada para manejar grandes conjuntos de datos con eficiencia.\\n4. **Consultas avanzadas**: Filtra y busca datos con condiciones complejas usando un sistema de consultas intuitivo.\\n\\n## Instalaci\xf3n\\n\\n```bash\\nnpm install @arcaelas/collection\\n# o usando yarn\\nyarn add @arcaelas/collection\\n```\\n\\n## Ejemplo b\xe1sico\\n\\n```typescript\\nimport { Collection } from \'@arcaelas/collection\';\\n\\n// Crear una colecci\xf3n de usuarios\\nconst usuarios = new Collection([\\n  { id: 1, nombre: \'Ana\', edad: 28, activo: true },\\n  { id: 2, nombre: \'Carlos\', edad: 35, activo: false },\\n  { id: 3, nombre: \'Elena\', edad: 23, activo: true },\\n  { id: 4, nombre: \'David\', edad: 42, activo: true }\\n]);\\n\\n// Filtrar usuarios activos y menores de 30 a\xf1os\\nconst jovenes_activos = usuarios\\n  .where({ activo: true })\\n  .where(usuario => usuario.edad < 30)\\n  .sortBy(\'edad\');\\n\\nconsole.log(jovenes_activos);\\n// Output: [{ id: 3, nombre: \'Elena\'... }, { id: 1, nombre: \'Ana\'... }]\\n```\\n\\nEn pr\xf3ximos art\xedculos exploraremos m\xe1s a fondo las capacidades de Arcaelas Collection y c\xf3mo puede ayudarte a escribir c\xf3digo m\xe1s limpio y mantenible para el manejo de datos."}]}}')}}]);